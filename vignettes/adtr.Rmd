---
title: "Creating ADTR"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Creating ADTR}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(admiral)
link <- function(text, url) {
  return(
    paste0(
      "[", text, "]",
      "(", url, ")"
    )
  )
}
dyn_link <- function(text,
                     base_url,
                     relative_url = "",
                     # Change to TRUE when admiral adopts multiversion docs
                     is_multiversion = FALSE,
                     multiversion_default_ref = "main") {
  url <- paste(base_url, relative_url, sep = "/")
  if (is_multiversion) {
    url <- paste(
      base_url,
      Sys.getenv("BRANCH_NAME", multiversion_default_ref),
      relative_url,
      sep = "/"
    )
  }
  return(link(text, url))
}
# Other variables
admiral_homepage <- "https://pharmaverse.github.io/admiral"
library(admiraldev)
```

# Introduction

This article describes creating an `ADTR` (Tumor Results) ADaM with common
oncology parameters based on RECIST v1.1.

The main part in programming a tumor results dataset is the calculation of the
sum of diameters of all target lesions (lymph nodes & non-lymph nodes), the
calculation of nadir, change & percentage change from baseline, and the
analysis flags that could be required for reporting.  The tumor results data could
be set up for investigator and/or Independent review facility (IRF)/Blinded
Independent Central Review (BICR) data.  The below sample code would need to be 
updated (for example, update the Evaluator 'TR.TREVAL', 'TU.TUEVAL', and the applicable 
parameter details 'PARAM' , 'PARAMCD', 'PARCATx') in order to create the acquired data for 
Independent review facility (IRF)/Blinded Independent Central Review (BICR).

The source dataset used will depend on each company,  this could be solely the
TR domain or you may merge `TU` with `TR` to get additional data variables or to
ensure that you're processing the same lesions as collected.

Individual lesion diameters for each target lesion (from `TR`) is required to
calculate the sum of diameters for all target lesions, this data could be taken 
directly from `TR` or additional parameters could be created in ADTR (or similar) 
depending on the additional processing required (e.g. imputation of dates, re-labeling 
of visits) and your company specifications.

The majority of the functions used here exist from '{admiral}'.

**Note**: *All examples assume CDISC SDTM and/or ADaM format as input unless
otherwise specified.*

## Required Packages

The examples of this vignette require the following packages. (This is to be
reviewed/updated once template code is written)

```{r, warning=FALSE, message=FALSE}
library(admiral)
library(dplyr)
library(admiral.test)
library(lubridate)
library(stringr)
```

# Programming Workflow

* [Read in Data](#readdata)
* [Merge TR with TU and derive new variables](#merge)
* [Pre-processing of input records](#input)
* [Derive Parameters for Lesion Diameters (LDIAMn, NLDIAMn)](#parameters)
* [Derive Parameter for Sum of Diameters (SDIAM) and ANL01FL](#sdiam)
* [Derive Baseline (ABLFL, BASE)](#base)
* [Derive NADIR](#nadir)
* [Derive Change from Baseline (CHG, PCHG)](#chg)
* [Derive Additional Flag Variables (e.g. CRFL, CRNFL, PDFL, PDFL](#addflag)
* [Derive Additional Analysis Flags (e.g. ANLxxFL](#analflag)
* [Derive Analysis Sequence Number (`ASEQ`)](#aseq)
* [Add ADSL Variables](#adslvars)

## Read in Data {#readdata}

To start, all data frames needed for the creation of the tumor results dataset
should be read into the environment. This will be a company specific process.
Some of the data frames needed may be `ADSL`, `ADRS` ,`RS`, `TU`, `TR`, 'SUPPTU' 
and 'SUPPTR'.

For example purposes, the SDTM and ADaM datasets (based on CDISC Pilot test
data)---which are included in `{admiral.test}`---are used.  Also, see [Handling of Missing Values] 
explains why we need to use the [convert_blanks_to_na] function.

```{r}
data("admiral_adsl")
data("admiral_adrs")
data("admiral_rs")
data("admiral_tu")
data("admiral_tr")
adsl <- admiral_adsl
adrs <- admiral_adrs
tu <- admiral_tu
tr <- admiral_tr
rs <- admiral_rs

tu <- convert_blanks_to_na(tu) %>%
  filter(TUEVAL == "INVESTIGATOR")
tr <- convert_blanks_to_na(tr) %>%
  filter(TREVAL == "INVESTIGATOR" & TRGRPID == "TARGET" & TRTESTCD == "DIAMETER")
rs <- convert_blanks_to_na(rs)
```

```{r echo=FALSE}
# work-around for https://github.com/pharmaverse/admiral.test/issues/98
# should be removed once the bug is fixed
tr <- ungroup(tr)
```

```{r echo=FALSE}
tr <- filter(tr, USUBJID %in% c("01-701-1015", "01-701-1023", "01-701-1028"))
```

At this step, it may be useful to join `ADSL` to your `TR` domain.  For efficiency, only the
`ADSL` variables (in this example, Randomization date 'RANDDT') used for derivations are selected at this step.  
The rest of the relevant `ADSL` variables would be added later.

```{r eval=TRUE}
adsl_vars <- vars(RANDDT)
tr <- derive_vars_merged(
  tr,
  dataset_add = adsl,
  new_vars = adsl_vars,
  by_vars = vars(STUDYID, USUBJID)
)
```

## Merge TR with TU and derive new variables {#merge}

Depending on your company specifications you may want to merge `TU` with `TR`. At this point 
if you require any new variables these could be added in this step. As an example, here we 
are keeping the tumor location ('TULOC'), and deriving a new variable for the tumor group site 
('TULOCGR1'). 

```{r}
tr <- derive_vars_merged(
  tr,
  dataset_add = rename(tu, TRLNKID = TULNKID),
  new_vars = vars(TULOC),
  by_vars = vars(STUDYID, USUBJID, TRLNKID)
) %>% mutate(
  TULOCGR1 = if_else(
    TULOC == "LYMPH NODE",
    "NODAL",
    "NON-NODAL"
  )
)
```

```{r, echo=FALSE}
dataset_vignette(tr, display_vars = vars(USUBJID, VISIT, TRLNKID, TULOC, TULOCGR1))
```  

Furthermore, you could create additional new variables that are required
downstream when deriving the required parameters. For example, here we include
lesion ID expected ('LSEXP') and lesion ID assessed ('LSASS').

```{r}
tr <- mutate(
  tr,
  LSEXP = TRLNKID,
  LSASS = if_else(!is.na(TRSTRESN), TRLNKID, NA_character_)
)
```

```{r, echo=FALSE}
dataset_vignette(tr, display_vars = vars(USUBJID, TRLNKID, LSEXP, LSASS))
```  

## Pre-processing of input records {#input}

The next step involves company-specific pre-processing of records required downstream 
prior to the parameter derivations to ensure that all the associated variable processing is done once,  
before any new parameters are derived. 

In order to calculate the sum of diameter of lesions, we need to 
ensure that lesions are grouped correctly,  how this is done will be based on your company spefications but 
individual lesions sizes could be grouped either by using the analysis date 'ADT' or by visit 'AVISIT'.  
This is to ensure that each lesion size is only counted once in the calculation.  

Below are some considerations depending on your analysis.

### Partial Date Imputation and Deriving `ADT`, `ADTF`, `AVISIT` etc

If your data collection allows for partial dates, you could apply a
company-specific imputation rule when deriving the analysis date `ADT` (you could also add further 
code to handle missing 'ADT', if this is a consideration).  

In the example below, we impute the missing day to the earliest possible date and derive the analysis date 'ADT', and then 
re-derive the analysis day 'ADY'.  

```{r}
tr <- derive_vars_dt(
  tr,
  dtc = TRDTC,
  new_vars_prefix = "A",
  highest_imputation = "D",
  date_imputation = "first"
) %>%
  derive_vars_dy(
    reference_date = RANDDT,
    source_vars = vars(ADT)
  )
```

```{r, echo=FALSE}
dataset_vignette(tr, display_vars = vars(USUBJID, RANDDT, TRLNKID, TRDTC, ADT, ADTF, ADY))
```  

### Unscheduled visits

If you have data collected at unscheduled visits, these could be identified as
uniquely in your SDTM.  However, if this is not the case and your grouping lesions by 
visit then you will need to amend the below code to apply company specific algorithm to 
re-label unscheduled visits as per your specifications.

```{r}
tr <- mutate(
  tr,
  AVISIT = VISIT,
  AVISITN = VISITNUM
)
```

## Derive Parameters for Lesion Diameters ('LDIAMn' and'NLDIAMn'){#parameters}

Depending on your company specifications you may either create parameters for Target Lesion diameter 
for lymph nodes ('LDIAMn') and non-lymph nodes ('NLDIAMn') in ADTR or similar dataset.

Set up the Parameter details and `AVAL/ANL01FL` variables.
      
```{r}
adtr <- tr %>%
  mutate(
    tmp_lesion_nr = str_sub(TRLNKID, 3),
    PARAMCD = paste0("DIAM", tmp_lesion_nr),
    PARAM = paste("Target Lesion", tmp_lesion_nr, "Analysis Diameter"),
    PARCAT1 = "Target Lesion(s)",
    PARCAT2 = "Investigator",
    PARCAT3 = "Recist 1.1",
    AVAL = TRSTRESN,
    ANL01FL = if_else(!is.na(AVAL), "Y", NA_character_)
  ) %>%
  select(-tmp_lesion_nr)
```

```{r, echo=FALSE}
dataset_vignette(
  arrange(adtr, USUBJID, TRLNKID, AVISITN),
  display_vars = vars(USUBJID, TRLNKID, AVISIT, PARAMCD, PARAM, AVAL, ANL01FL)
)
```

## Derive Parameter for Sum of Diameter and Analysis Flag `ANL01FL` {#SDIAM}

Sum of Target Lesions Diameters is the sum of the diameters of both lymph and
non-lymph nodes (sum of analysis values `AVAL` from source observations 'LDIAMn' &
'LNDIAMn').   

In this vignette, the sum of the diameters is counted across all available lesion measurements, the ANL01FL
describes the additional derivations required as per RECIST 1.1, and subsequently we build on this analysis 
flag (ANLxxFL) to demonstrate additional analysis flags as example purposes only. The analysis flags therefore 
should be setup according to your company specifications.

In the example below, the lesion size are counted and grouped according to the 
by variables specified, in this case we group according to the visit ('AVISIT' and 'AVISIT') to 
ensure that the correct lesion measurements are summed together. 

```{r}
adtr_sum <- get_summary_records(
  adtr,
  by_vars = vars(STUDYID, USUBJID, !!!adsl_vars, AVISIT, AVISITN),
  analysis_var = AVAL,
  summary_fun = function(x) sum(x, na.rm = TRUE),
  set_values_to = vars(
    PARAMCD = "SDIAM",
    PARAM = "Target Lesions Sum of Diameters by Investigator",
    PARCAT1 = "Target Lesion(s)",
    PARCAT2 = "Investigator",
    PARCAT3 = "Recist 1.1"
  )
)
```

```{r, echo=FALSE}
dataset_vignette(
  arrange(adtr_sum, USUBJID, AVISITN),
  d]isplay_vars = vars(USUBJID, PARAMCD, PARAM, AVISIT, AVAL)
)
```  

The analysis flag `ANL01FL` flags the sum of diameters where the number of lesions assessed
at baseline and at post-baseline match.  To assess whether the number of lesions
expected and assessed match, you could compare lesion identifiers (`TR.TRLNKID`)
or use the previous variables set up earlier to compare lesion expected ('LSEXP') vs lesion
assessed ('LSASS') or check for target lesion response (from `RS`) = 'NE'.   A target lesion 
response of 'NE' means all lesions from baseline are not measured at that post-baseline visit.   

Lesions can split or merge, if this is a consideration then this needs to be taken care 
of when deciding on algorithms to use to check if all lesions are measured at post-baseline.

In the below example, the analysis flag, ANL01FL= Y identifies the largest
target lesion sum of diameter on a particular date for reporting if there were
multiple observations on the same date and where lesion assessed at
post-baseline match baseline.

NEED TO ADD MORE COMMENTS FOR THIS BLOCK OF CODE - TO COME BACK TO THIS.

```{r}
adtr_sum <- adtr_sum %>%
  derive_var_merged_summary(
    dataset_add = adtr,
    by_vars = vars(USUBJID),
    filter_add = AVISIT == "BASELINE" & str_detect(PARAMCD, "DIAM[12345]"),
    new_var = LSEXP,
    analysis_var = TRLNKID,
    summary_fun = function(x) paste(sort(x), collapse = ", ")
  ) %>%
  derive_var_merged_summary(
    dataset_add = adtr,
    by_vars = vars(USUBJID, AVISIT),
    filter_add = str_detect(PARAMCD, "DIAM[12345]") & ANL01FL == "Y",
    new_var = LSASS,
    analysis_var = TRLNKID,
    summary_fun = function(x) paste(sort(x), collapse = ", ")
  ) %>%
  derive_var_merged_summary(
    dataset_add = adtr,
    by_vars = vars(USUBJID, AVISIT),
    filter_add = str_detect(PARAMCD, "DIAM[12345]"),
    new_var = ADY,
    analysis_var = ADY,
    summary_fun = function(x) min(x, na.rm = TRUE)
  ) %>%
  derive_var_merged_summary(
    dataset_add = adtr,
    by_vars = vars(USUBJID, AVISIT),
    filter_add = str_detect(PARAMCD, "DIAM[12345]"),
    new_var = ADT,
    analysis_var = ADT,
    summary_fun = function(x) min(x, na.rm = TRUE)
  ) %>%
  mutate(
    ANL01FL = if_else(LSEXP == LSASS, "Y", NA_character_)
  )
```

```{r, echo=FALSE}
dataset_vignette(
  arrange(adtr_sum, USUBJID, AVISITN),
  display_vars = vars(USUBJID, PARAMCD, AVISIT, LSEXP, LSASS, ADT, ADY)
)
```  


## Derive Baseline (`ABLFL`, `BASE`) {#base}

These functions are available in `admiral`, below examples show its usage for `ADTR`. Here
we defined baseline as the last value.

```{r}
adtr_sum <- adtr_sum %>%
  restrict_derivation(
    derivation = derive_var_extreme_flag,
    args = params(
      by_vars = vars(USUBJID),
      order = vars(ADY),
      new_var = ABLFL,
      mode = "last"
    ),
    filter = ADY <= 1
  ) %>%
  derive_var_base(
    by_vars = vars(USUBJID)
  )
```

## Derive `NADIR` {#nadir}

Once we have Sum of Target Diameters parameter ('SDIAM'), the 'NADIR' is set to the lowest sum of diameters in
Analysis Value ('AVAL') before the current observation, where all lesions were assessed (i.e ANL01FL=Y).  The
first observations after baseline (depending on how you have defined baseline
earlier) is set to the baseline value.

```{r}
adtr_sum <- adtr_sum %>%
  derive_vars_joined(
    dataset_add = adtr_sum,
    by_vars = vars(USUBJID),
    order = vars(AVAL),
    new_vars = vars(NADIR = AVAL),
    join_vars = vars(ADY),
    filter_add = ADY > 0 & ANL01FL == "Y",
    filter_join = ADY.join < ADY,
    mode = "first",
    check_type = "none"
  )
```

```{r, echo=FALSE}
dataset_vignette(
  arrange(adtr_sum, USUBJID, AVISITN),
  display_vars = vars(USUBJID, PARAMCD, AVISIT, AVAL, NADIR)
)
```  

## Derive Change from Baseline (`CHG`, `PCHG`) {#chg}

These functions are available in 'admiral', below examples show its usage for
`ADTR`.  We calculate the change from baseline and percentage change from
baseline for the parameter 'SDIAM' and the variable `NADIR`.

```{r}
adtr_sum <- adtr_sum %>%
  derive_var_chg() %>%
  derive_var_pchg() %>%
  mutate(
    CHGNAD = AVAL - NADIR,
    PCHGNAD = 100 * CHGNAD / NADIR
  )
```

```{r, echo=FALSE}
dataset_vignette(
  arrange(adtr_sum, USUBJID, AVISITN),
  display_vars = vars(USUBJID, AVISIT, AVAL, NADIR, ,BASE, CHG, PCHG, CHGNAD, PCHGNAD)
)
```  

## Derive Additional Flag Variables {#addflag}

Depending on the analysis flags you require, you may want to create additional
flag variables that will then aid setting up any additional analysis flag
variables defined as per your company specifications.

### Derive `PDFL`

In this example, we want to flag when a patient has had PD.  This could be done
in a number of ways:

1. take the date of PD from `ADRS`

2. take the first date when the overall response is PD from `RS` or

3. Calculate from source data, the derivation for PD for target lesions is based
on the calculated sum of diameters of the assessed lesions results in a
calculated Percent Change from NADIR >=20% and a calculated Change from NADIR
>=5mm depending on your company specifications.

4. Target lesion response of no 'CR' at the current observation visit and but a 'CR' response 
at the nadir observation
  
See below example.

```{r}
adtr_sum <- adtr_sum %>%
  mutate(
    PDFL = if_else(PCHGNAD >= 20 & CHGNAD >= 5 | is.na(CRFL) & CRNFL == "Y", "Y", NA_character_)
  )
```

```{r, echo=FALSE}
dataset_vignette(
  arrange(adtr_sum, USUBJID, AVISITN),
  display_vars = vars(USUBJID, AVISIT, AVAL, NADIR, CHGNAD, PCHGNAD, PDFL)
)
```
  
In this example, `CRFL` flags where the patient has had Complete Response, and
`CRNFL`, flags where Complete response contributed to the NADIR calculation.
    

```{r}
adtr_sum <- adtr_sum %>% mutate(
  CRFL = if_else(AVAL == 0 & ANL01FL == "Y", "Y", NA_character_),
  CRNFL = if_else(NADIR == 0, "Y", NA_character_)
)
```    

## Derive Analysis Flags `ANLxxFL` {#analflag}

Based on your analysis, additional analysis flags could be set up in `ADTR`.
Below are some examples

Analysis 02 Flag only includes the visit with the lowest NADIR (lowest sum of
diameter) compared across all visits.  Using the lowest percentage change from baseline ('PCHG').

```{r}
adtr_sum <- adtr_sum %>%
  restrict_derivation(
    derivation = derive_var_extreme_flag,
    args = params(
      by_vars = vars(USUBJID),
      new_var = ANL02FL,
      order = vars(AVAL),
      mode = "first"
    ),
    filter = ANL01FL == "Y"
  )
```

```{r, echo=FALSE}
dataset_vignette(
  arrange(adtr_sum, USUBJID, AVISITN),
  display_vars = vars(USUBJID, AVISIT, AVAL, NADIR, ANL02FL)
)
```  

Analysis 03 flag includes `ANL01FL="Y"` and the sum of diameters
until patient has had PD. Use the `PDFL` variable.

```{r}
adtr_sum <- adtr_sum %>%
  restrict_derivation(
    derivation = derive_var_relative_flag,
    args = params(
      by_vars = vars(USUBJID),
      new_var = ANL03FL,
      condition = PDFL == "Y",
      order = vars(ADY),
      mode = "first",
      selection = "before",
      inclusive = TRUE
    ),
    filter = ANL01FL == "Y"
  )
```

```{r, echo=FALSE}
dataset_vignette(
  arrange(adtr_sum, USUBJID, AVISITN),
  display_vars = vars(USUBJID, AVISIT, AVAL, NADIR, PDFL, ANL03FL)
)
```  

Analysis 04 flag includes all sum of diameters where all lesions were assessed and additionally those indicating PD. 
Use 'PDFL' variable.
  
```{r}
adtr_sum <- adtr_sum %>%
  mutate(
    ANL04FL = if_else(ANL01FL == "Y" | PDFL == "Y", "Y", NA_character_)
  )
```

```{r, echo=FALSE}
dataset_vignette(
  arrange(adtr_sum, USUBJID, AVISITN),
  display_vars = vars(USUBJID, AVISIT, AVAL, NADIR, PDFL, ANL01FL, ANL04FL)
)
```  


```{r}
adtr <- bind_rows(adtr, adtr_sum)
```

## Derive Analysis Sequence Number (`ASEQ`) {#aseq}

The `{admiral}` function `admiral::derive_var_obs_number()` can be used to
derive `ASEQ`:

```{r eval=TRUE}
adtr <- adtr %>%
  derive_var_obs_number(
    by_vars = vars(STUDYID, USUBJID),
    order = vars(PARAMCD, AVISITN, TRSEQ),
    check_type = "error"
  )
```

```{r, echo=FALSE}
dataset_vignette(
  arrange(adtr, USUBJID, ASEQ),
  display_vars = vars(USUBJID, PARAMCD, AVISIT, ASEQ, AVAL)
)
```  


## Add ADSL Variables {#adslvars}
  
If needed, the other `ADSL` variables can now be added. List of `ADSL`
variables already merged held in vector `adsl_vars`.

```{r eval=TRUE}
adtr <- adtr %>%
  derive_vars_merged(
    dataset_add = select(adsl, !!!negate_vars(adsl_vars)),
    by_vars = vars(STUDYID, USUBJID)
  )
```

```{r, eval=TRUE, echo=FALSE}
dataset_vignette(
  adtr,
  display_vars = vars(USUBJID, RFSTDTC, RFENDTC, DTHDTC, DTHFL, AGE, AGEU)
)
```


# Example Script {#example}

ADaM | Sample Code
---- | --------------
ADTR | [ad_adtr.R](https://github.com/pharmaverse/admiralonco/blob/main/inst/templates/ad_adtr.R){target="_blank"}




